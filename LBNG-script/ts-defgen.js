"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const URLClassLoader_1 = require("jvm-types/java/net/URLClassLoader");
const File_1 = require("jvm-types/java/io/File");
const Thread_1 = require("jvm-types/java/lang/Thread");
const Paths_1 = require("jvm-types/java/nio/file/Paths");
// @ts-expect-error
const HashMap_1 = require("jvm-types/java/util/HashMap");
// @ts-expect-error
const ArrayList_1 = require("jvm-types/java/util/ArrayList");
const JvmClassMappingKt_1 = require("jvm-types/kotlin/jvm/JvmClassMappingKt");
const Class_1 = require("jvm-types/java/lang/Class");
const ScriptModule_1 = require("jvm-types/net/ccbluex/liquidbounce/script/bindings/features/ScriptModule");
const ClassPath_1 = require("jvm-types/com/google/common/reflect/ClassPath");
const ScriptManager_1 = require("jvm-types/net/ccbluex/liquidbounce/script/ScriptManager");
const LiquidBounce_1 = require("jvm-types/net/ccbluex/liquidbounce/LiquidBounce");
const LocalDate_1 = require("jvm-types/java/time/LocalDate");
const DateTimeFormatter_1 = require("jvm-types/java/time/format/DateTimeFormatter");
const inDev = LiquidBounce_1.LiquidBounce.IN_DEVELOPMENT;
// type: array
/** @type any[] */
const globalEntries = Object.entries(globalThis);
// Function to create a URLClassLoader from a JAR path
function createClassLoaderFromJar(jarPath) {
    try {
        // Create File object for the JAR
        const jarFile = new File_1.File(jarPath);
        // Convert File to URL
        const jarUrl = jarFile.toURI().toURL();
        // Create URLClassLoader with the system class loader as parent
        return new URLClassLoader_1.URLClassLoader([jarUrl], Thread_1.Thread.currentThread().getContextClassLoader());
    }
    catch (e) {
        console.error("Error creating ClassLoader:", e);
        throw e;
    }
}
// Function to load a class from a given ClassLoader
function loadClassFromJar(classLoader, className) {
    try {
        return classLoader.loadClass(className);
    }
    catch (e) {
        console.error(`Error loading class ${className}:`, e);
        throw e;
    }
}
// @ts-expect-error
function findAllClassInfos() {
    // @ts-expect-error
    return Java.from(ClassPath_1.ClassPath.from(Thread_1.Thread.currentThread()
        .getContextClassLoader())
        .getTopLevelClasses()
        // @ts-expect-error
        .asList());
}
function getName(javaClass) {
    const fullName = javaClass.name;
    return fullName.substring(fullName.lastIndexOf(".") + 1);
}
const script = registerScript.apply({
    name: "ts-defgen",
    version: "1.0.0",
    authors: ["commandblock2"],
});
function work(path, packageName) {
    try {
        const loader = createClassLoaderFromJar(path + "/ts-generator.jar");
        const NPMGen = loadClassFromJar(loader, "me.commandblock2.tsGenerator.NPMPackageGenerator");
        const TsGen = loadClassFromJar(loader, "me.ntrrgc.tsGenerator.TypeScriptGenerator");
        const VoidType = loadClassFromJar(loader, "me.ntrrgc.tsGenerator.VoidType");
        const NULL = VoidType.getEnumConstants()[0];
        const javaClasses = globalEntries
            .filter((entry) => entry[1] != undefined)
            .map((entry) => (entry[1] instanceof Class_1.Class ? entry[1] : entry[1].class))
            .filter((entry) => entry != undefined);
        const eventEntries = ReflectionUtil.getDeclaredField(ScriptModule_1.ScriptModule, "LOWERCASE_NAME_EVENT_MAP").entrySet().toArray();
        Client.displayChatMessage("looking for all jvm classes");
        const allClassInfos = findAllClassInfos();
        Client.displayChatMessage(`found ${allClassInfos.length} classes, converting to kotlin classes`);
        const classNames = ["java.net.URLClassLoader",
            "java.nio.file.Paths",
            "java.util.HashMap",
            "java.util.ArrayList",
            "java.util.jar.JarInputStream",
            "java.util.Map",
            "com.google.common.reflect.ClassPath",
            "kotlin.jvm.JvmClassMappingKt"
        ]
            .concat(allClassInfos.map((entry) => {
            try {
                return entry.getName();
            }
            catch (e) {
                return null;
            }
        }));
        const jvmClasses = classNames
            .map((entry) => {
            try {
                return ReflectionUtil.classByName(entry);
            }
            catch (e) {
                return null;
            }
        })
            .filter((entry) => entry != undefined);
        const jvmClassesInKotlin = jvmClasses
            .map((entry) => {
            try {
                return JvmClassMappingKt_1.JvmClassMappingKt.getKotlinClass(entry);
            }
            catch (e) {
                return null;
            }
        })
            .filter((entry) => entry != null);
        Client.displayChatMessage(`converted to ${jvmClassesInKotlin.length} kotlin classes`);
        const kotlinClasses = javaClasses
            .concat([
            // Using the imported class from @embedded
            ReflectionUtil.classByName("net.ccbluex.liquidbounce.script.bindings.features.ScriptModule")
        ])
            .concat(eventEntries.map((entry) => entry[1]))
            .map(entry => {
            try {
                return JvmClassMappingKt_1.JvmClassMappingKt.getKotlinClass(entry);
            }
            catch (e) {
                return null;
            }
        })
            .filter((entry) => entry != undefined)
            .concat(jvmClassesInKotlin);
        const classes = new ArrayList_1.ArrayList(kotlinClasses);
        Client.displayChatMessage(`generating types for ${classes.length} classes`);
        Client.displayChatMessage("this may take a while, please wait...");
        // @ts-expect-error
        const generated = new TsGen(classes, new HashMap_1.HashMap(), new ArrayList_1.ArrayList(), new ArrayList_1.ArrayList(), "number", NULL);
        const today = LocalDate_1.LocalDate.now();
        const formatter = DateTimeFormatter_1.DateTimeFormatter.ofPattern('y.M.d');
        Client.displayChatMessage("writing types");
        // @ts-expect-error
        const npmPack = new NPMGen(generated, packageName, `${inDev ? today.format(formatter) : LiquidBounce_1.LiquidBounce.INSTANCE.clientVersion}+${LiquidBounce_1.LiquidBounce.INSTANCE.clientBranch}.${LiquidBounce_1.LiquidBounce.INSTANCE.clientCommit}`, 
        // extraFiles - add the ambient and augmentations files
        `"augmentations/**/*.d.ts", "ambient/ambient.d.ts"`, 
        // extraTypesVersion - add the augmentations and ambient paths  
        `"./augmentations/*", "ambient/ambient.d.ts"`, 
        // otherExtras - add the types field
        `"types": "ambient/ambient.d.ts"`);
        npmPack.writePackageTo(
        // @ts-expect-error
        Paths_1.Paths.get(path + "/types-gen"));
        Client.displayChatMessage("print embedded script types, see log for more info, those are for maintainace use");
        const embeddedDefinition = `
// ambient.ts
// imports
import "../augmentations/index.d.ts"
${javaClasses
            .map((clazz) => {
            return `import { ${getName(clazz)} as ${getName(clazz)}_ } from "../types/${clazz.name.replaceAll(".", "/")}";`;
        })
            .join("\n")}
declare global {


// exports
${globalEntries
            .filter((entry) => entry[1] != undefined)
            .filter((entry) => !(entry[1] instanceof Class_1.Class))
            .filter((entry) => entry[1].class != undefined)
            .map((entry) => `    export const ${entry[0]}: ${getName(entry[1].class)}_;`)
            .join("\n\n")}

${javaClasses
            .map((clazz) => {
            var _a, _b;
            // Check if this class is exported as a constructor (appears in globalEntries as Class)
            const isExportedAsClass = globalEntries.some(([name, value]) => value instanceof Class_1.Class && value === clazz);
            if (isExportedAsClass) {
                const exportName = (_a = globalEntries.find(([name, value]) => value instanceof Class_1.Class && value === clazz)) === null || _a === void 0 ? void 0 : _a[0];
                // Determine if it's a concrete class or interface
                // You might need to adjust this logic based on how you distinguish them
                const isInterface = ((_b = clazz.isInterface) === null || _b === void 0 ? void 0 : _b.call(clazz)) || false; // Adjust this condition as needed
                if (isInterface) {
                    return `    export const ${exportName}: ${getName(clazz)}_;`;
                }
                else {
                    return `    export const ${exportName}: typeof ${getName(clazz)}_;`;
                }
            }
            return null;
        })
            .filter((entry) => entry !== null)
            .join("\n\n")}

}
`;
        const importsForScriptEventPatch = `
// imports for
${eventEntries.map((entry) => entry[1]).map((kClassImpl) => `import type { ${kClassImpl.simpleName} } from '../types/${kClassImpl.qualifiedName.replaceAll(".", "/")}.d.ts'`).join("\n")}


`;
        const onEventsForScriptPatch = `
// on events
${eventEntries.map((entry) => `on(eventName: "${entry[0]}", handler: (${entry[0]}Event: ${entry[1].simpleName}) => void): Unit;`).join("\n")}


`;
        Client.displayChatMessage("Generated TypeScript definitions successfully!");
        Client.displayChatMessage(`Output path: ${path}/types-gen`);
        // Output the generated content to console for debugging
        console.log(embeddedDefinition);
        // @ts-expect-error
        const Files = Java.type('java.nio.file.Files');
        // @ts-expect-error
        const filePath = Paths_1.Paths.get(`${path}/types-gen/${packageName}/ambient/ambient.d.ts`);
        // @ts-expect-error
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, embeddedDefinition, 
        // @ts-expect-error
        Java.type("java.nio.charset.StandardCharsets").UTF_8);
        // Write the ScriptModule augmentation file
        const augmentationContent = `// ScriptModule augmentation - adds event handler interfaces

// Event type imports
${importsForScriptEventPatch}
import type { Unit } from '../types/kotlin/Unit';

// Augment ScriptModule with specific event handler overloads
declare module '../types/net/ccbluex/liquidbounce/script/bindings/features/ScriptModule' {
    interface ScriptModule {
        on(eventName: "enable" | "disable", handler: () => void): Unit;

        // on events with specific event types
        ${onEventsForScriptPatch}
    }
}
`;
        // @ts-expect-error
        const augmentationFilePath = Paths_1.Paths.get(`${path}/types-gen/${packageName}/augmentations/ScriptModule.augmentation.d.ts`);
        // @ts-expect-error
        Files.createDirectories(augmentationFilePath.getParent());
        Files.writeString(augmentationFilePath, augmentationContent, 
        // @ts-expect-error
        Java.type("java.nio.charset.StandardCharsets").UTF_8);
        console.log(importsForScriptEventPatch);
        console.log(onEventsForScriptPatch);
    }
    catch (e) {
        console.error(e);
        Client.displayChatMessage(`Error generating TypeScript definitions: ${e.message}`);
        e.printStackTrace();
        throw e;
    }
}
const packageName = "jvm-types";
const path = ScriptManager_1.ScriptManager.INSTANCE.root.path;
// @ts-expect-error
if (Java.type("java.lang.System").getenv("CI_BUILD")) {
    work(path, packageName);
    mc.close();
}
script.registerCommand({
    name: "ts-defgen",
    aliases: ["tsgen"],
    parameters: [],
    onExecute() {
        // @ts-expect-error
        UnsafeThread.run(() => work(path, packageName));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHMtZGVmZ2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3RzLWRlZmdlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHNFQUFtRTtBQUNuRSxpREFBOEM7QUFFOUMsdURBQW9EO0FBQ3BELHlEQUFzRDtBQUN0RCxtQkFBbUI7QUFDbkIseURBQXNEO0FBQ3RELG1CQUFtQjtBQUNuQiw2REFBMEQ7QUFDMUQsOEVBQTJFO0FBQzNFLHFEQUFrRDtBQUNsRCwyR0FBd0c7QUFLeEcsNkVBQTBFO0FBQzFFLDJGQUF3RjtBQUl4RixrRkFBOEU7QUFDOUUsNkRBQTBEO0FBQzFELG9GQUFpRjtBQUVqRixNQUFNLEtBQUssR0FBRywyQkFBWSxDQUFDLGNBQWMsQ0FBQTtBQUV6QyxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFakQsc0RBQXNEO0FBQ3RELFNBQVMsd0JBQXdCLENBQUMsT0FBZTtJQUM3QyxJQUFJLENBQUM7UUFDRCxpQ0FBaUM7UUFDakMsTUFBTSxPQUFPLEdBQUcsSUFBSSxXQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFbEMsc0JBQXNCO1FBQ3RCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUV2QywrREFBK0Q7UUFDL0QsT0FBTyxJQUFJLCtCQUFjLENBQ3JCLENBQUMsTUFBTSxDQUFDLEVBQ1IsZUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDLHFCQUFxQixFQUFFLENBQ2pELENBQUM7SUFDTixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNULE9BQU8sQ0FBQyxLQUFLLENBQUMsNkJBQTZCLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEQsTUFBTSxDQUFDLENBQUM7SUFDWixDQUFDO0FBQ0wsQ0FBQztBQUVELG9EQUFvRDtBQUNwRCxTQUFTLGdCQUFnQixD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bkIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7SUFDbkQsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQTtJQUN2QixFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDZixDQUFDO0FBRUQsTUFBTSxDQUFDLGVBQWUsQ0FBQztJQUNuQixJQUFJLEVBQUUsV0FBVztJQUNqQixPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDbEIsVUFBVSxFQUFFLEVBQ1g7SUFDRCxTQUFTO1FBQ0wsbUJBQW1CO1FBQ25CLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Q0FDSixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVUkxDbGFzc0xvYWRlciB9IGZyb20gXCJqdm0tdHlwZXMvamF2YS9uZXQvVVJMQ2xhc3NMb2FkZXJcIjtcbmltcG9ydCB7IEZpbGUgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvaW8vRmlsZVwiO1xuaW1wb3J0IHsgVVJMIH0gZnJvbSBcImp2bS10eXBlcy9qYXZhL25ldC9VUkxcIjtcbmltcG9ydCB7IFRocmVhZCB9IGZyb20gXCJqdm0tdHlwZXMvamF2YS9sYW5nL1RocmVhZFwiO1xuaW1wb3J0IHsgUGF0aHMgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvbmlvL2ZpbGUvUGF0aHNcIjtcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmltcG9ydCB7IEhhc2hNYXAgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvdXRpbC9IYXNoTWFwXCI7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgeyBBcnJheUxpc3QgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvdXRpbC9BcnJheUxpc3RcIjtcbmltcG9ydCB7IEp2bUNsYXNzTWFwcGluZ0t0IH0gZnJvbSBcImp2bS10eXBlcy9rb3RsaW4vanZtL0p2bUNsYXNzTWFwcGluZ0t0XCI7XG5pbXBvcnQgeyBDbGFzcyB9IGZyb20gXCJqdm0tdHlwZXMvamF2YS9sYW5nL0NsYXNzXCI7XG5pbXBvcnQgeyBTY3JpcHRNb2R1bGUgfSBmcm9tIFwianZtLXR5cGVzL25ldC9jY2JsdWV4L2xpcXVpZGJvdW5jZS9zY3JpcHQvYmluZGluZ3MvZmVhdHVyZXMvU2NyaXB0TW9kdWxlXCI7XG5pbXBvcnQgeyBPYmplY3QgYXMgSmF2YU9iamVjdCB9IGZyb20gXCJqdm0tdHlwZXMvamF2YS9sYW5nL09iamVjdFwiO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IHsgTWFwIGFzIEphdmFNYXAgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvdXRpbC9NYXBcIjtcbmltcG9ydCB7IFRocm93YWJsZSB9IGZyb20gXCJqdm0tdHlwZXMvamF2YS9sYW5nL1Rocm93YWJsZVwiO1xuaW1wb3J0IHsgQ2xhc3NQYXRoIH0gZnJvbSBcImp2bS10eXBlcy9jb20vZ29vZ2xlL2NvbW1vbi9yZWZsZWN0L0NsYXNzUGF0aFwiO1xuaW1wb3J0IHsgU2NyaXB0TWFuYWdlciB9IGZyb20gXCJqdm0tdHlwZXMvbmV0L2NjYmx1ZXgvbGlxdWlkYm91bmNlL3NjcmlwdC9TY3JpcHRNYW5hZ2VyXCI7XG5pbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tIFwianZtLXR5cGVzL2phdmEvbGFuZy9FeGNlcHRpb25cIjtcbmltcG9ydCB7IEZpbGVzS3QgfSBmcm9tIFwianZtLXR5cGVzL2tvdGxpbi9pby9GaWxlc0t0XCI7XG5pbXBvcnQgeyBGaWxlIGFzIEphdmFGaWxlIH0gZnJvbSBcImp2bS10eXBlcy9qYXZhL2lvL0ZpbGVcIjtcbmltcG9ydCB7IExpcXVpZEJvdW5jZSB9IGZyb20gXCJqdm0tdHlwZXMvbmV0L2NjYmx1ZXgvbGlxdWlkYm91bmNlL0xpcXVpZEJvdW5jZVwiXG5pbXBvcnQgeyBMb2NhbERhdGUgfSBmcm9tIFwianZtLXR5cGVzL2phdmEvdGltZS9Mb2NhbERhdGVcIjtcbmltcG9ydCB7IERhdGVUaW1lRm9ybWF0dGVyIH0gZnJvbSBcImp2bS10eXBlcy9qYXZhL3RpbWUvZm9ybWF0L0RhdGVUaW1lRm9ybWF0dGVyXCI7XG5cbmNvbnN0IGluRGV2ID0gTGlxdWlkQm91bmNlLklOX0RFVkVMT1BNRU5UXG5cbi8vIHR5cGU6IGFycmF5XG4vKiogQHR5cGUgYW55W10gKi9cbmNvbnN0IGdsb2JhbEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhnbG9iYWxUaGlzKTtcblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGEgVVJMQ2xhc3NMb2FkZXIgZnJvbSBhIEpBUiBwYXRoXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0xvYWRlckZyb21KYXIoamFyUGF0aDogc3RyaW5nKTogVVJMQ2xhc3NMb2FkZXIge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBGaWxlIG9iamVjdCBmb3IgdGhlIEpBUlxuICAgICAgICBjb25zdCBqYXJGaWxlID0gbmV3IEZpbGUoamFyUGF0aCk7XG5cbiAgICAgICAgLy8gQ29udmVydCBGaWxlIHRvIFVSTFxuICAgICAgICBjb25zdCBqYXJVcmwgPSBqYXJGaWxlLnRvVVJJKCkudG9VUkwoKTtcblxuICAgICAgICAvLyBDcmVhdGUgVVJMQ2xhc3NMb2FkZXIgd2l0aCB0aGUgc3lzdGVtIGNsYXNzIGxvYWRlciBhcyBwYXJlbnRcbiAgICAgICAgcmV0dXJuIG5ldyBVUkxDbGFzc0xvYWRlcihcbiAgICAgICAgICAgIFtqYXJVcmxdLFxuICAgICAgICAgICAgVGhyZWFkLmN1cnJlbnRUaHJlYWQoKS5nZXRDb250ZXh0Q2xhc3NMb2FkZXIoKVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIENsYXNzTG9hZGVyOlwiLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGxvYWQgYSBjbGFzcyBmcm9tIGEgZ2l2ZW4gQ2xhc3NMb2FkZXJcbmZ1bmN0aW9uIGxvYWRDbGFzc0Zyb21KYXIoY2xhc3NMb2FkZXI6IFVSTENsYXNzTG9hZGVyLCBjbGFzc05hbWU6IHN0cmluZyk6IENsYXNzPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjbGFzc0xvYWRlci5sb2FkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgY2xhc3MgJHtjbGFzc05hbWV9OmAsIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gZmluZEFsbENsYXNzSW5mb3MoKTogQ2xhc3NJbmZvPGFueT5bXSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJldHVybiBKYXZhLmZyb20oXG4gICAgICAgIENsYXNzUGF0aC5mcm9tKFxuICAgICAgICAgICAgVGhyZWFkLmN1cnJlbnRUaHJlYWQoKVxuICAgICAgICAgICAgICAgIC5nZXRDb250ZXh0Q2xhc3NMb2FkZXIoKVxuICAgICAgICApXG4gICAgICAgICAgICAuZ2V0VG9wTGV2ZWxDbGFzc2VzKClcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIC5hc0xpc3QoKVxuICAgICk7XG59XG5cblxuZnVuY3Rpb24gZ2V0TmFtZShqYXZhQ2xhc3M6IENsYXNzPGFueT4pOiBzdHJpbmcge1xuICAgIGNvbnN0IGZ1bGxOYW1lID0gamF2YUNsYXNzLm5hbWU7XG4gICAgcmV0dXJuIGZ1bGxOYW1lLnN1YnN0cmluZyhmdWxsTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbn1cblxuY29uc3Qgc2NyaXB0ID0gcmVnaXN0ZXJTY3JpcHQuYXBwbHkoe1xuICAgIG5hbWU6IFwidHMtZGVmZ2VuXCIsXG4gICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgIGF1dGhvcnM6IFtcImNvbW1hbmRibG9jazJcIl0sXG59KTtcblxuZnVuY3Rpb24gd29yayhwYXRoOiBzdHJpbmcsIHBhY2thZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBjcmVhdGVDbGFzc0xvYWRlckZyb21KYXIoXG4gICAgICAgICAgICBwYXRoICsgXCIvdHMtZ2VuZXJhdG9yLmphclwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IE5QTUdlbiA9IGxvYWRDbGFzc0Zyb21KYXIoXG4gICAgICAgICAgICBsb2FkZXIsXG4gICAgICAgICAgICBcIm1lLmNvbW1hbmRibG9jazIudHNHZW5lcmF0b3IuTlBNUGFja2FnZUdlbmVyYXRvclwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IFRzR2VuID0gbG9hZENsYXNzRnJvbUphcihcbiAgICAgICAgICAgIGxvYWRlcixcbiAgICAgICAgICAgIFwibWUubnRycmdjLnRzR2VuZXJhdG9yLlR5cGVTY3JpcHRHZW5lcmF0b3JcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBWb2lkVHlwZSA9IGxvYWRDbGFzc0Zyb21KYXIoXG4gICAgICAgICAgICBsb2FkZXIsXG4gICAgICAgICAgICBcIm1lLm50cnJnYy50c0dlbmVyYXRvci5Wb2lkVHlwZVwiXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgTlVMTCA9IFZvaWRUeXBlLmdldEVudW1Db25zdGFudHMoKVswXTtcblxuICAgICAgICBjb25zdCBqYXZhQ2xhc3NlcyA9IGdsb2JhbEVudHJpZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeVsxXSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAubWFwKChlbnRyeSkgPT4gKGVudHJ5WzFdIGluc3RhbmNlb2YgQ2xhc3MgPyBlbnRyeVsxXSA6IGVudHJ5WzFdLmNsYXNzKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeSAhPSB1bmRlZmluZWQpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50RW50cmllcyA9IChSZWZsZWN0aW9uVXRpbC5nZXREZWNsYXJlZEZpZWxkKFNjcmlwdE1vZHVsZSBhcyB1bmtub3duIGFzIENsYXNzPEphdmFPYmplY3Q+LCBcIkxPV0VSQ0FTRV9OQU1FX0VWRU5UX01BUFwiKSBhcyBKYXZhTWFwKS5lbnRyeVNldCgpLnRvQXJyYXkoKTtcblxuICAgICAgICBDbGllbnQuZGlzcGxheUNoYXRNZXNzYWdlKFwibG9va2luZyBmb3IgYWxsIGp2bSBjbGFzc2VzXCIpXG4gICAgICAgIGNvbnN0IGFsbENsYXNzSW5mb3MgPSBmaW5kQWxsQ2xhc3NJbmZvcygpXG5cbiAgICAgICAgQ2xpZW50LmRpc3BsYXlDaGF0TWVzc2FnZShgZm91bmQgJHthbGxDbGFzc0luZm9zLmxlbmd0aH0gY2xhc3NlcywgY29udmVydGluZyB0byBrb3RsaW4gY2xhc3Nlc2ApXG5cblxuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gW1wiamF2YS5uZXQuVVJMQ2xhc3NMb2FkZXJcIixcbiAgICAgICAgICAgIFwiamF2YS5uaW8uZmlsZS5QYXRoc1wiLFxuICAgICAgICAgICAgXCJqYXZhLnV0aWwuSGFzaE1hcFwiLFxuICAgICAgICAgICAgXCJqYXZhLnV0aWwuQXJyYXlMaXN0XCIsXG4gICAgICAgICAgICBcImphdmEudXRpbC5qYXIuSmFySW5wdXRTdHJlYW1cIixcbiAgICAgICAgICAgIFwiamF2YS51dGlsLk1hcFwiLFxuICAgICAgICAgICAgXCJjb20uZ29vZ2xlLmNvbW1vbi5yZWZsZWN0LkNsYXNzUGF0aFwiLFxuICAgICAgICAgICAgXCJrb3RsaW4uanZtLkp2bUNsYXNzTWFwcGluZ0t0XCJcbiAgICAgICAgXVxuICAgICAgICAgICAgLmNvbmNhdChhbGxDbGFzc0luZm9zLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuZ2V0TmFtZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QganZtQ2xhc3NlcyA9IGNsYXNzTmFtZXNcbiAgICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Rpb25VdGlsLmNsYXNzQnlOYW1lKGVudHJ5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkgIT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QganZtQ2xhc3Nlc0luS290bGluID0ganZtQ2xhc3Nlc1xuICAgICAgICAgICAgLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSnZtQ2xhc3NNYXBwaW5nS3QuZ2V0S290bGluQ2xhc3MoZW50cnkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeSAhPSBudWxsKTtcblxuICAgICAgICBDbGllbnQuZGlzcGxheUNoYXRNZXNzYWdlKGBjb252ZXJ0ZWQgdG8gJHtqdm1DbGFzc2VzSW5Lb3RsaW4ubGVuZ3RofSBrb3RsaW4gY2xhc3Nlc2ApXG4gICAgICAgIGNvbnN0IGtvdGxpbkNsYXNzZXMgPSBqYXZhQ2xhc3Nlc1xuICAgICAgICAgICAgLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgdGhlIGltcG9ydGVkIGNsYXNzIGZyb20gQGVtYmVkZGVkXG4gICAgICAgICAgICAgICAgUmVmbGVjdGlvblV0aWwuY2xhc3NCeU5hbWUoXG4gICAgICAgICAgICAgICAgICAgIFwibmV0LmNjYmx1ZXgubGlxdWlkYm91bmNlLnNjcmlwdC5iaW5kaW5ncy5mZWF0dXJlcy5TY3JpcHRNb2R1bGVcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAuY29uY2F0KGV2ZW50RW50cmllcy5tYXAoKGVudHJ5OiBhbnkpID0+IChlbnRyeSBhcyBBcnJheTxhbnk+KVsxXSkpXG4gICAgICAgICAgICAubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSnZtQ2xhc3NNYXBwaW5nS3QuZ2V0S290bGluQ2xhc3MoZW50cnkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICBqdm1DbGFzc2VzSW5Lb3RsaW5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IG5ldyBBcnJheUxpc3Qoa290bGluQ2xhc3Nlcyk7XG5cbiAgICAgICAgQ2xpZW50LmRpc3BsYXlDaGF0TWVzc2FnZShgZ2VuZXJhdGluZyB0eXBlcyBmb3IgJHtjbGFzc2VzLmxlbmd0aH0gY2xhc3Nlc2ApXG4gICAgICAgIENsaWVudC5kaXNwbGF5Q2hhdE1lc3NhZ2UoXCJ0aGlzIG1heSB0YWtlIGEgd2hpbGUsIHBsZWFzZSB3YWl0Li4uXCIpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IG5ldyBUc0dlbihcbiAgICAgICAgICAgIGNsYXNzZXMsXG4gICAgICAgICAgICBuZXcgSGFzaE1hcCgpLFxuICAgICAgICAgICAgbmV3IEFycmF5TGlzdCgpLFxuICAgICAgICAgICAgbmV3IEFycmF5TGlzdCgpLFxuICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgIE5VTExcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB0b2RheSA9IExvY2FsRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIub2ZQYXR0ZXJuKCd5Lk0uZCcpO1xuXG4gICAgICAgIENsaWVudC5kaXNwbGF5Q2hhdE1lc3NhZ2UoXCJ3cml0aW5nIHR5cGVzXCIpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IG5wbVBhY2sgPSBuZXcgTlBNR2VuKGdlbmVyYXRlZCwgcGFja2FnZU5hbWUsXG4gICAgICAgICAgICBgJHtpbkRldiA/IHRvZGF5LmZvcm1hdChmb3JtYXR0ZXIpIDogTGlxdWlkQm91bmNlLklOU1RBTkNFLmNsaWVudFZlcnNpb25cbiAgICAgICAgICAgIH0rJHtMaXF1aWRCb3VuY2UuSU5TVEFOQ0UuY2xpZW50QnJhbmNofS4ke0xpcXVpZEJvdW5jZS5JTlNUQU5DRS5jbGllbnRDb21taXR9YCxcbiAgICAgICAgICAgIC8vIGV4dHJhRmlsZXMgLSBhZGQgdGhlIGFtYmllbnQgYW5kIGF1Z21lbnRhdGlvbnMgZmlsZXNcbiAgICAgICAgICAgIGBcImF1Z21lbnRhdGlvbnMvKiovKi5kLnRzXCIsIFwiYW1iaWVudC9hbWJpZW50LmQudHNcImAsXG4gICAgICAgICAgICAvLyBleHRyYVR5cGVzVmVyc2lvbiAtIGFkZCB0aGUgYXVnbWVudGF0aW9ucyBhbmQgYW1iaWVudCBwYXRocyAgXG4gICAgICAgICAgICBgXCIuL2F1Z21lbnRhdGlvbnMvKlwiLCBcImFtYmllbnQvYW1iaWVudC5kLnRzXCJgLFxuICAgICAgICAgICAgLy8gb3RoZXJFeHRyYXMgLSBhZGQgdGhlIHR5cGVzIGZpZWxkXG4gICAgICAgICAgICBgXCJ0eXBlc1wiOiBcImFtYmllbnQvYW1iaWVudC5kLnRzXCJgXG4gICAgICAgICk7XG5cbiAgICAgICAgbnBtUGFjay53cml0ZVBhY2thZ2VUbyhcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIFBhdGhzLmdldChwYXRoICsgXCIvdHlwZXMtZ2VuXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgQ2xpZW50LmRpc3BsYXlDaGF0TWVzc2FnZShcInByaW50IGVtYmVkZGVkIHNjcmlwdCB0eXBlcywgc2VlIGxvZyBmb3IgbW9yZSBpbmZvLCB0aG9zZSBhcmUgZm9yIG1haW50YWluYWNlIHVzZVwiKVxuXG4gICAgICAgIGNvbnN0IGVtYmVkZGVkRGVmaW5pdGlvbiA9IGBcbi8vIGFtYmllbnQudHNcbi8vIGltcG9ydHNcbmltcG9ydCBcIi4uL2F1Z21lbnRhdGlvbnMvaW5kZXguZC50c1wiXG4ke2phdmFDbGFzc2VzXG4gICAgICAgICAgICAgICAgLm1hcCgoY2xhenopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBpbXBvcnQgeyAke2dldE5hbWUoY2xhenopfSBhcyAke2dldE5hbWUoY2xhenopfV8gfSBmcm9tIFwiLi4vdHlwZXMvJHtjbGF6ei5uYW1lLnJlcGxhY2VBbGwoXCIuXCIsIFwiL1wiKX1cIjtgO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcXG5cIil9XG5kZWNsYXJlIGdsb2JhbCB7XG5cblxuLy8gZXhwb3J0c1xuJHtnbG9iYWxFbnRyaWVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5WzFdICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gIShlbnRyeVsxXSBpbnN0YW5jZW9mIENsYXNzKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnlbMV0uY2xhc3MgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiBgICAgIGV4cG9ydCBjb25zdCAke2VudHJ5WzBdfTogJHtnZXROYW1lKGVudHJ5WzFdLmNsYXNzKX1fO2ApXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcXG5cXG5cIil9XG5cbiR7amF2YUNsYXNzZXNcbiAgICAgICAgICAgICAgICAubWFwKChjbGF6eikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNsYXNzIGlzIGV4cG9ydGVkIGFzIGEgY29uc3RydWN0b3IgKGFwcGVhcnMgaW4gZ2xvYmFsRW50cmllcyBhcyBDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFeHBvcnRlZEFzQ2xhc3MgPSBnbG9iYWxFbnRyaWVzLnNvbWUoKFtuYW1lLCB2YWx1ZV0pID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyAmJiB2YWx1ZSA9PT0gY2xhenpcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V4cG9ydGVkQXNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IGdsb2JhbEVudHJpZXMuZmluZCgoW25hbWUsIHZhbHVlXSkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyAmJiB2YWx1ZSA9PT0gY2xhenpcbiAgICAgICAgICAgICAgICAgICAgICAgICk/LlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGl0J3MgYSBjb25jcmV0ZSBjbGFzcyBvciBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlvdSBtaWdodCBuZWVkIHRvIGFkanVzdCB0aGlzIGxvZ2ljIGJhc2VkIG9uIGhvdyB5b3UgZGlzdGluZ3Vpc2ggdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmZhY2UgPSBjbGF6ei5pc0ludGVyZmFjZT8uKCkgfHwgZmFsc2U7IC8vIEFkanVzdCB0aGlzIGNvbmRpdGlvbiBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAgICAgZXhwb3J0IGNvbnN0ICR7ZXhwb3J0TmFtZX06ICR7Z2V0TmFtZShjbGF6eil9XztgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCAgICBleHBvcnQgY29uc3QgJHtleHBvcnROYW1lfTogdHlwZW9mICR7Z2V0TmFtZShjbGF6eil9XztgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXFxuXCIpfVxuXG59XG5gXG5cbiAgICAgICAgY29uc3QgaW1wb3J0c0ZvclNjcmlwdEV2ZW50UGF0Y2ggPSBgXG4vLyBpbXBvcnRzIGZvclxuJHtldmVudEVudHJpZXMubWFwKChlbnRyeTogYW55KSA9PiBlbnRyeVsxXSkubWFwKChrQ2xhc3NJbXBsOiBhbnkpID0+IGBpbXBvcnQgdHlwZSB7ICR7a0NsYXNzSW1wbC5zaW1wbGVOYW1lfSB9IGZyb20gJy4uL3R5cGVzLyR7a0NsYXNzSW1wbC5xdWFsaWZpZWROYW1lLnJlcGxhY2VBbGwoXCIuXCIsIFwiL1wiKX0uZC50cydgKS5qb2luKFwiXFxuXCIpfVxuXG5cbmA7XG4gICAgICAgIGNvbnN0IG9uRXZlbnRzRm9yU2NyaXB0UGF0Y2ggPSBgXG4vLyBvbiBldmVudHNcbiR7ZXZlbnRFbnRyaWVzLm1hcCgoZW50cnk6IGFueSkgPT4gYG9uKGV2ZW50TmFtZTogXCIke2VudHJ5WzBdfVwiLCBoYW5kbGVyOiAoJHtlbnRyeVswXX1FdmVudDogJHtlbnRyeVsxXS5zaW1wbGVOYW1lfSkgPT4gdm9pZCk6IFVuaXQ7YCkuam9pbihcIlxcblwiKX1cblxuXG5gO1xuXG4gICAgICAgIENsaWVudC5kaXNwbGF5Q2hhdE1lc3NhZ2UoXCJHZW5lcmF0ZWQgVHlwZVNjcmlwdCBkZWZpbml0aW9ucyBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgICBDbGllbnQuZGlzcGxheUNoYXRNZXNzYWdlKGBPdXRwdXQgcGF0aDogJHtwYXRofS90eXBlcy1nZW5gKTtcblxuICAgICAgICAvLyBPdXRwdXQgdGhlIGdlbmVyYXRlZCBjb250ZW50IHRvIGNvbnNvbGUgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zb2xlLmxvZyhlbWJlZGRlZERlZmluaXRpb24pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IEZpbGVzID0gSmF2YS50eXBlKCdqYXZhLm5pby5maWxlLkZpbGVzJylcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IFBhdGhzLmdldChgJHtwYXRofS90eXBlcy1nZW4vJHtwYWNrYWdlTmFtZX0vYW1iaWVudC9hbWJpZW50LmQudHNgKTtcblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIEZpbGVzLmNyZWF0ZURpcmVjdG9yaWVzKGZpbGVQYXRoLmdldFBhcmVudCgpKTtcblxuICAgICAgICBGaWxlcy53cml0ZVN0cmluZyhcbiAgICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICAgICAgZW1iZWRkZWREZWZpbml0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgSmF2YS50eXBlKFwiamF2YS5uaW8uY2hhcnNldC5TdGFuZGFyZENoYXJzZXRzXCIpLlVURl84XG4gICAgICAgIClcblxuICAgICAgICAvLyBXcml0ZSB0aGUgU2NyaXB0TW9kdWxlIGF1Z21lbnRhdGlvbiBmaWxlXG4gICAgICAgIGNvbnN0IGF1Z21lbnRhdGlvbkNvbnRlbnQgPSBgLy8gU2NyaXB0TW9kdWxlIGF1Z21lbnRhdGlvbiAtIGFkZHMgZXZlbnQgaGFuZGxlciBpbnRlcmZhY2VzXG5cbi8vIEV2ZW50IHR5cGUgaW1wb3J0c1xuJHtpbXBvcnRzRm9yU2NyaXB0RXZlbnRQYXRjaH1cbmltcG9ydCB0eXBlIHsgVW5pdCB9IGZyb20gJy4uL3R5cGVzL2tvdGxpbi9Vbml0JztcblxuLy8gQXVnbWVudCBTY3JpcHRNb2R1bGUgd2l0aCBzcGVjaWZpYyBldmVudCBoYW5kbGVyIG92ZXJsb2Fkc1xuZGVjbGFyZSBtb2R1bGUgJy4uL3R5cGVzL25ldC9jY2JsdWV4L2xpcXVpZGJvdW5jZS9zY3JpcHQvYmluZGluZ3MvZmVhdHVyZXMvU2NyaXB0TW9kdWxlJyB7XG4gICAgaW50ZXJmYWNlIFNjcmlwdE1vZHVsZSB7XG4gICAgICAgIG9uKGV2ZW50TmFtZTogXCJlbmFibGVcIiB8IFwiZGlzYWJsZVwiLCBoYW5kbGVyOiAoKSA9PiB2b2lkKTogVW5pdDtcblxuICAgICAgICAvLyBvbiBldmVudHMgd2l0aCBzcGVjaWZpYyBldmVudCB0eXBlc1xuICAgICAgICAke29uRXZlbnRzRm9yU2NyaXB0UGF0Y2h9XG4gICAgfVxufVxuYDtcblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IGF1Z21lbnRhdGlvbkZpbGVQYXRoID0gUGF0aHMuZ2V0KGAke3BhdGh9L3R5cGVzLWdlbi8ke3BhY2thZ2VOYW1lfS9hdWdtZW50YXRpb25zL1NjcmlwdE1vZHVsZS5hdWdtZW50YXRpb24uZC50c2ApO1xuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgRmlsZXMuY3JlYXRlRGlyZWN0b3JpZXMoYXVnbWVudGF0aW9uRmlsZVBhdGguZ2V0UGFyZW50KCkpO1xuXG4gICAgICAgIEZpbGVzLndyaXRlU3RyaW5nKFxuICAgICAgICAgICAgYXVnbWVudGF0aW9uRmlsZVBhdGgsXG4gICAgICAgICAgICBhdWdtZW50YXRpb25Db250ZW50LFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgSmF2YS50eXBlKFwiamF2YS5uaW8uY2hhcnNldC5TdGFuZGFyZENoYXJzZXRzXCIpLlVURl84XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc29sZS5sb2coaW1wb3J0c0ZvclNjcmlwdEV2ZW50UGF0Y2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhvbkV2ZW50c0ZvclNjcmlwdFBhdGNoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIENsaWVudC5kaXNwbGF5Q2hhdE1lc3NhZ2UoYEVycm9yIGdlbmVyYXRpbmcgVHlwZVNjcmlwdCBkZWZpbml0aW9uczogJHsoZSBhcyBUaHJvd2FibGUpLm1lc3NhZ2V9YCk7XG4gICAgICAgIChlIGFzIEV4Y2VwdGlvbikucHJpbnRTdGFja1RyYWNlKClcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5cbmNvbnN0IHBhY2thZ2VOYW1lID0gXCJqdm0tdHlwZXNcIlxuY29uc3QgcGF0aCA9IFNjcmlwdE1hbmFnZXIuSU5TVEFOQ0Uucm9vdC5wYXRoO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pZiAoSmF2YS50eXBlKFwiamF2YS5sYW5nLlN5c3RlbVwiKS5nZXRlbnYoXCJDSV9CVUlMRFwiKSkge1xuICAgIHdvcmsocGF0aCwgcGFja2FnZU5hbWUpXG4gICAgbWMuY2xvc2UoKTtcbn1cblxuc2NyaXB0LnJlZ2lzdGVyQ29tbWFuZCh7XG4gICAgbmFtZTogXCJ0cy1kZWZnZW5cIixcbiAgICBhbGlhc2VzOiBbXCJ0c2dlblwiXSxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgXSxcbiAgICBvbkV4ZWN1dGUoKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgVW5zYWZlVGhyZWFkLnJ1bigoKSA9PiB3b3JrKHBhdGgsIHBhY2thZ2VOYW1lKSk7XG4gICAgfVxufSk7XG4iXX0=